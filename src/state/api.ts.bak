import { cleanParams, createNewUserInDatabase, withToast } from "@/lib/utils"
// Ensure prismaTypes correctly defines these or import directly from @prisma/client if preferred
// Assuming Tenant and Manager are the correct types for user details from DB
import type { Application, Lease, Manager, Payment, Property, Room, Tenant } from "@/types/prismaTypes"
// Import the Cognito User type if available, or define a minimal structure
import type { AuthUser as CognitoAuthUser } from 'aws-amplify/auth'; // Example import path
// Import RTK Query types
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react"
import type { FetchBaseQueryError } from '@reduxjs/toolkit/query';
import type { TagDescription } from '@reduxjs/toolkit/query';
import { toast } from 'sonner';

import { fetchAuthSession, getCurrentUser } from "aws-amplify/auth"
import type { FiltersState } from "." // Assuming FiltersState is defined in the same directory

// Use relative paths for Next.js API routes
const API_BASE_URL = '/api';
// No need to check for environment variables since we're using relative paths

// --- Define a specific type for the authenticated user state ---
// Define Admin type to match the structure needed for admin users
export interface Admin {
  id: number;
  cognitoId: string;
  name: string;
  email: string;
}

export interface AppUser {
  cognitoInfo: CognitoAuthUser; // Use the type from aws-amplify/auth
  userInfo: Tenant | Manager | Admin;   // The user details from your database (Tenant, Manager, or Admin)
  userRole: "tenant" | "manager" | "admin";
}
// --- End AppUser Definition ---

// Define the valid tag types used throughout the API slice
type CacheTagType = "Applications" | "Managers" | "Tenants" | "Properties" | "PropertyDetails" | "Leases" | "Payments" | "Rooms" | "Admins";


export const api = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: API_BASE_URL,
    timeout: 60000, // Increase timeout to 60 seconds
    prepareHeaders: async (headers) => {
      try {
        const session = await fetchAuthSession();
        const idToken = session.tokens?.idToken?.toString();
        if (idToken) {
          headers.set("Authorization", `Bearer ${idToken}`);
        }
      } catch (error) {
        // Silently handle auth errors - this allows non-authenticated users to access public endpoints
        console.log("User not authenticated, continuing as guest");
      }
      return headers;
    },
    // Add response handling to properly handle non-JSON responses
    validateStatus: (response, body) => {
      if (response.status === 404) {
        // Return empty array for 404s on list endpoints
        if (response.url.includes('/rooms')) {
          return true;
        }
      }
      return response.status >= 200 && response.status < 300;
    },
    // Add custom response handling with retry logic
    async fetchFn(input, init) {
      const maxRetries = 3;
      let retries = 0;
      let lastError;
      
      while (retries < maxRetries) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
          
          // Create a new Request object for each attempt to prevent reuse errors
          let requestInput = input;
          if (input instanceof Request) {
            // Clone the request properties but create a fresh Request object
            const url = input.url;
            const method = input.method;
            const headers = new Headers(input.headers);
            let body = null;
            
            // Only try to clone the body if it exists and we're not on a GET/HEAD request
            if (method !== 'GET' && method !== 'HEAD') {
              try {
                // We can't directly access the body, but we can create a new one from init if available
                if (init?.body) {
                  body = init.body;
                }
              } catch (e) {
                console.warn('Could not clone request body:', e);
              }
            }
            
            // Create a fresh Request object with the same properties
            requestInput = new Request(url, {
              method,
              headers,
              body,
              mode: input.mode,
              credentials: input.credentials,
              cache: input.cache,
              redirect: input.redirect,
              referrer: input.referrer,
              integrity: input.integrity,
            });
          }
          
          const response = await fetch(requestInput, {
            ...init,
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          // Clone the response before reading it
          const clonedResponse = response.clone();
      
      try {
        // Try to parse as JSON first
        const data = await response.json();
        // Create a new Response with the JSON data
        return new Response(JSON.stringify(data), {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } catch (e) {
        // If parsing fails, handle based on status
        if (response.status === 404 && response.url.includes('/rooms')) {
          // Return empty array for 404s on rooms endpoint
          return new Response(JSON.stringify([]), {
            status: 200,
            statusText: 'OK',
            headers: response.headers
          });
        }
        
        // For other errors, get the text from the cloned response
        const errorText = await clonedResponse.text();
        throw {
          status: response.status,
          data: errorText,
          originalStatus: response.status
        };
      }
        } catch (error) {
          lastError = error;
          retries++;
          console.log(`API request failed, retry attempt ${retries}/${maxRetries}`);
          
          if (retries >= maxRetries) {
            console.error('Max retries reached, throwing last error:', error);
            throw error;
          }
          
          // Exponential backoff: 1s, 2s, 4s, etc.
          const delay = Math.min(1000 * Math.pow(2, retries - 1), 10000);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      
      // This should never be reached due to the throw in the loop, but TypeScript needs it
      throw lastError;
    }
  }),
  reducerPath: "api",
  tagTypes: ["Managers", "Tenants", "Properties", "PropertyDetails", "Leases", "Payments", "Applications", "Rooms", "Admins"],
  endpoints: (build) => ({
    // --- Use the new AppUser type ---
    getAuthUser: build.query<AppUser, void>({
      queryFn: async (_, _queryApi, _extraoptions, fetchWithBQ) => {
        try {
          console.log("Starting getAuthUser queryFn");
          
          const session = await fetchAuthSession();
          console.log("Auth session fetched:", { 
            hasSession: !!session, 
            hasTokens: !!session?.tokens,
            hasIdToken: !!session?.tokens?.idToken 
          });
          
          // Check if we have a valid session with tokens before attempting to get current user
          if (!session?.tokens?.idToken) {
            console.log("No valid session found, returning error");
            return { 
              error: { 
                status: 401, 
                error: "No valid session found",
                data: "User not authenticated"
              } 
            } as const;
          }
          
          const idToken = session.tokens.idToken;
          
          try {
            const cognitoUser = await getCurrentUser();
            console.log("Cognito user fetched:", { 
              hasUser: !!cognitoUser,
              userId: cognitoUser?.userId,
              username: cognitoUser?.username
            });
            
            const rawUserRole = idToken.payload["custom:role"] as string;
            const userEmail = typeof cognitoUser?.signInDetails?.loginId === 'string' ? 
              cognitoUser.signInDetails.loginId.toLowerCase() : '';
            console.log("User role from token:", rawUserRole);
            console.log("User email:", userEmail);

            if (!cognitoUser) {
              console.log("No authenticated user found, returning error");
              // Instead of returning null, return a proper error object
              // This ensures type compatibility with RTK Query
              return { 
                error: { 
                  status: 401, 
                  error: "No authenticated user found",
                  data: "User not authenticated"
                } 
              } as const;
            }

            // Check if user is an admin based on role or special email
            const isAdmin = rawUserRole === "admin" || userEmail === "admin@student24.co.za";
            
            // Determine user role with proper admin handling
            const userRole = isAdmin ? "admin" : (rawUserRole === "manager" ? "manager" : "tenant") as "tenant" | "manager" | "admin";
            
            console.log("Determined user role:", { userRole, isAdmin, rawUserRole, userEmail });
            
            // Determine the endpoint based on user role, but don't set endpoint for admin users
            // as we'll handle them separately without an API call
            let endpoint = "";
            if (userRole === "manager") {
              endpoint = `/managers/${cognitoUser.userId}`;
            } else if (userRole === "tenant") {
              endpoint = `/tenants/${cognitoUser.userId}`;
            }
          
            // For admin users, construct admin info directly without API call
            if (userRole === "admin") {
              console.log("Admin user detected, creating admin user object");
              
              // Construct admin info directly without API call
              // Extract a better name from the email or user attributes
              let adminName = "Admin User";
              
              // Try to get name from user attributes if available
              if (cognitoUser.username && cognitoUser.username !== "admin_" + cognitoUser.userId) {
                adminName = cognitoUser.username;
              } 
              // If email is available, use part before @ as name
              else if (userEmail && userEmail !== "admin@student24.co.za") {
                const emailName = userEmail.split('@')[0];
                // Convert email name to proper case (e.g., john.doe -> John Doe)
                adminName = emailName
                  .replace(/\./g, ' ')
                  .replace(/\b\w/g, c => c.toUpperCase());
              }
              
              const adminInfo: Admin = {
                id: 0, // Use appropriate ID or generate one
                cognitoId: cognitoUser.userId,
                name: adminName,
                email: userEmail || ""
              };
              
              // Return admin user directly
              const appUserData: AppUser = {
                cognitoInfo: cognitoUser,
                userInfo: adminInfo,
                userRole: "admin",
              };
              
              console.log("Admin user authenticated:", appUserData);
              return { data: appUserData } as const;
            }
            // Skip API calls for admin users as we've already handled them above
            if (userRole === "admin") {
              console.log("Admin user detected, skipping API calls");
              return { data: null } as const;
            }
            
            console.log("Fetching user details from endpoint:", endpoint);
            
            // Define userDetailsResponse at a higher scope so it's accessible after all try-catch blocks
            // Initialize with a default error state
            let userDetailsResponse: any = { error: { status: 500, error: "Initialization error" } };
            
            // Only attempt to fetch user details if we have a valid endpoint
            if (endpoint) {
              try {
                userDetailsResponse = await fetchWithBQ(endpoint);
                
                console.log("User details response:", {
                  hasError: !!userDetailsResponse.error,
                  hasData: !!userDetailsResponse.data,
                  status: (userDetailsResponse.error as any)?.status
                });
              } catch (error) {
                console.error("Error fetching user details:", error);
                return { 
                  error: { 
                    status: 401, 
                    error: "Error fetching user details",
                    data: error instanceof Error ? error.message : "Unknown error"
                  } 
                } as const;
              }
            } else {
              console.log("No endpoint specified for user details, skipping fetch");
              // Return early with appropriate error for missing endpoint
              return {
                error: {
                  status: 400,
                  error: "Invalid user role or missing endpoint",
                  data: "Could not determine appropriate API endpoint for user role"
                }
              } as const;
            }
                  data: error instanceof Error ? error.message : "Unknown error"
                } 
              } as const;
            }
          } catch (error) {
            console.error("Error getting current user:", error);
            return { 
              error: { 
                status: 401, 
                error: "Authentication error",
                data: error instanceof Error ? error.message : "Unknown error"
              } 
            } as const;
          }

          // if user doesn't exist or there's a timeout, create new user
          if (userDetailsResponse.error && 
              ((userDetailsResponse.error as any).status === 404 || 
               (userDetailsResponse.error as any).status === 504)) {
            console.log("User not found, attempting to create new user");
            userDetailsResponse = await createNewUserInDatabase(cognitoUser, idToken, userRole, fetchWithBQ);
            console.log("New user creation response:", {
              hasError: !!userDetailsResponse.error,
              hasData: !!userDetailsResponse.data
            });
          }

          if(userDetailsResponse.error){
            console.error("Error in user details response:", JSON.stringify(userDetailsResponse.error, null, 2));
            
            // Check if this is a database connection error
            if (userDetailsResponse.error.status === 500 && 
                (typeof userDetailsResponse.error.data === 'string' && (
                 userDetailsResponse.error.data.includes('prisma') || 
                 userDetailsResponse.error.data.includes('database')))) {
              console.error("Database connection error detected");
              return { 
                error: { 
                  status: 500, 
                  error: "Database connection error",
                  data: "Please check your database connection"
                } 
              } as const;
            }
            
            // For 403 errors (role-based access issues)
            if (userDetailsResponse.error.status === 403) {
              console.error("Permission error: User role doesn't have access");
              return { 
                error: { 
                  status: 403, 
                  error: "Permission denied",
                  data: "Your role doesn't have access to this resource"
                } 
              } as const;
            }
            
            throw userDetailsResponse.error;
          }

          // --- Construct the AppUser object ---
          const appUserData: AppUser = {
            cognitoInfo: cognitoUser,
            userInfo: userDetailsResponse.data as Tenant | Manager | Admin,
            userRole,
          };

          console.log("Successfully constructed AppUser data", { userRole });
          return { data: appUserData } as const;
        } catch (error: any) {
            // More defensive error logging
            const errorDetails = {
                message: error?.message || 'No error message',
                status: error?.status || 'No status',
                data: error?.data || 'No data',
                stack: error?.stack || 'No stack trace',
                name: error?.name || 'No error name',
                code: error?.code || 'No error code',
                type: error?.constructor?.name || 'Unknown error type',
                isError: error instanceof Error,
                stringified: typeof error === 'object' ? JSON.stringify(error, Object.getOwnPropertyNames(error), 2) : String(error)
            };
            
            console.error("Error in getAuthUser queryFn:", errorDetails);
            
            // More detailed error message construction
            const errorMessage = error?.message || 
                               error?.data?.message || 
                               (error?.status === 401 ? "Authentication failed" : 
                                error?.status === 404 ? "User not found" :
                                error?.status === 504 ? "Server timeout - please try again" :
                                "Could not fetch user data");
                               
            // If this is a timeout error, we can return a fallback user state
            if (error?.status === 504) {
              console.log("Timeout error, returning fallback user state");
              // You could return a cached user here if available
              // For now, we'll just return the error
            }
            
            return { 
                error: { 
                    status: error?.status || 'CUSTOM_ERROR', 
                    error: errorMessage,
                    details: errorDetails
                } 
            } as const;
        }
      },
      providesTags: (result) => result?.userInfo
        ? (result.userRole === 'manager'
            ? [{ type: 'Managers', id: (result.userInfo as Manager).id }]
            : [{ type: 'Tenants', id: (result.userInfo as Tenant).id }])
        : [],
    }),

    // Property related endpoints
    getProperties: build.query<Property[], Partial<FiltersState> & { favoriteIds?: number[] }>({
      query: (filters) => {
        const params = cleanParams({
          location: filters.location,
          priceMin: filters.priceRange?.[0],
          priceMax: filters.priceRange?.[1],
          beds: filters.beds,
          baths: filters.baths,
          propertyType: filters.propertyType,
          squareFeetMin: filters.squareFeet?.[0],
          squareFeetMax: filters.squareFeet?.[1],
          amenities: filters.amenities?.join(","),
          availableFrom: filters.availableFrom,
          favoriteIds: filters.favoriteIds?.join(","),
          latitude: filters.coordinates?.[1],
          longitude: filters.coordinates?.[0],
        });

        return { url: "properties", params };
      },
      providesTags: (result) =>
        result
          ? [...result.map(({ id }) => ({ type: "Properties" as const, id })), { type: "Properties", id: "LIST" }]
          : [{ type: "Properties", id: "LIST" }],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to fetch properties.",
        });
      },
    }),

    getProperty: build.query<Property, number>({
      query: (id) => {
        return {
          url: `properties/${id}`,
          method: 'GET',
        };
      },
      transformErrorResponse: (response: any) => {
        if (response?.status === 404) {
          console.error('Property not found:', response);
          return { data: null };
        }
        return response;
      },
      providesTags: (result, error, id) => [{ type: "PropertyDetails", id }],
      async onQueryStarted(_, { queryFulfilled }) {
        try {
          await queryFulfilled;
        } catch (error) {
          console.error("Failed to load property details:", error);
        }
      },
    }),

    // Create property with JSON data (no files)
    createProperty: build.mutation<Property, { propertyData: any, photoFiles?: File[] }>({
      async queryFn({ propertyData, photoFiles }, { dispatch, getState }, _extraOptions, baseQuery) {
        try {
          // First create the property without photos
          console.log('Creating property with data:', propertyData);
          const propertyResponse = await baseQuery({
            url: 'properties',
            method: 'POST',
            // Ensure the body is properly serialized as JSON
            body: JSON.stringify({ ...propertyData, photoUrls: [] }),
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (propertyResponse.error) {
            console.error('Error creating property:', propertyResponse.error);
            return { error: propertyResponse.error as FetchBaseQueryError };
          }
          
          const property = propertyResponse.data as Property;
          
          // If we have files to upload, do it in a second step
          if (photoFiles && photoFiles.length > 0) {
            try {
              // Upload each file individually
              const uploadPromises = photoFiles.map(async (file) => {
                console.log(`Uploading photo: ${file.name}, size: ${file.size}`);
                const formData = new FormData();
                formData.append('photo', file);
                formData.append('propertyId', property.id.toString());
                
                // Use a more direct approach for FormData
                const uploadResponse = await fetch(`/api/properties/${property.id}/photos`, {
                  method: 'POST',
                  body: formData,
                  // Don't set Content-Type, let the browser handle it
                }).then(res => res.json()).catch(err => {
                  console.error('Error in photo upload fetch:', err);
                  return { error: { status: 'FETCH_ERROR', error: err.message } };
                });
                
                // Convert the fetch response to the format expected by RTK Query
                if (uploadResponse.error) {
                  console.error('Error uploading photo:', uploadResponse.error);
                  throw new Error(uploadResponse.error.message || 'Error uploading photo');
                }
                
                return uploadResponse;
              });
              
              // Wait for all uploads to complete
              const uploadResults = await Promise.all(uploadPromises);
              console.log('All photos uploaded successfully:', uploadResults);
              
              // Get the updated property with photo URLs
              const updatedPropertyResponse = await baseQuery({
                url: `properties/${property.id}`,
                method: 'GET',
              });
              
              if (updatedPropertyResponse.error) {
                return { error: updatedPropertyResponse.error as FetchBaseQueryError };
              }
              
              return { data: updatedPropertyResponse.data as Property };
            } catch (uploadError) {
              console.error('Error during photo upload:', uploadError);
              // Return the property even if photo upload failed
              return { data: property };
            }
          }
          
          return { data: property };
        } catch (error) {
          console.error('Error in createProperty mutation:', error);
          return { 
            error: { 
              status: 'CUSTOM_ERROR',
              error: error instanceof Error ? error.message : String(error),
            } as FetchBaseQueryError 
          };
        }
      },
      invalidatesTags: (result) => [
        { type: "Properties", id: "LIST" },
        result ? { type: "PropertyDetails", id: result.id } : { type: "Properties", id: "LIST" },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Property created successfully!",
          error: "Failed to create property.",
        });
      },
    }),

    updateProperty: build.mutation<Property, { id: string; body: FormData }>({
        query: ({ id, body }) => {
            // Create a new FormData object to avoid modifying the original
            const cleanFormData = new FormData();
            
            // Copy all fields except replacePhotos
            for (const [key, value] of body.entries()) {
                if (key !== 'replacePhotos') {
                    cleanFormData.append(key, value);
                }
            }
            
            return {
                url: `properties/${id}`,
                method: "PUT",
                body: cleanFormData,
            };
        },
        invalidatesTags: (result, error, { id }) => [
            { type: "Properties", id: "LIST" },
            { type: "PropertyDetails", id: Number(id) },
        ],
        async onQueryStarted(_, { queryFulfilled }) {
            await withToast(queryFulfilled, {
                success: "Property updated successfully!",
                error: "Failed to update property.",
            });
        },
    }),

    deleteProperty: build.mutation<{ message: string; id: number }, { id: number; managerCognitoId?: string }>({
        query: ({ id, managerCognitoId }) => {
            // Ensure ID is a number
            const numericId = typeof id === 'string' ? parseInt(id, 10) : id;
            
            // Build the URL with the manager ID as part of the query string
            const url = `properties/${numericId}`;
            
            return {
                url,
                method: "DELETE",
                params: managerCognitoId ? { managerCognitoId } : undefined,
            };
        },
        transformErrorResponse: (response: any) => {
            console.error('Delete property error response:', response);
            const message = response.data?.message || 
                          `Failed to delete property (Status: ${response.status})`;
            return { data: { message } };
        },
        invalidatesTags: (result, error, { id }) => [
            { type: "Properties", id: "LIST" },
            { type: "PropertyDetails", id },
        ],
        async onQueryStarted(_, { queryFulfilled }) {
            try {
                const result = await queryFulfilled;
                toast.success("Property deleted successfully!");
            } catch (error: any) {
                console.error("Error deleting property:", error);
                toast.error(error?.data?.message || "Failed to delete property.");
            }
        },
    }),


    // Tenant related endpoints
    getTenant: build.query<Tenant, string>({
      query: (cognitoId) => `tenants/${cognitoId}`,
      providesTags: (result) => (result ? [{ type: "Tenants", id: result.id }] : []),
      // No error toast for tenant profile loading
    }),

    getCurrentResidences: build.query<Property[], string>({
      query: (cognitoId) => `tenants/${cognitoId}/current-residences`,
      providesTags: (result) =>
        result
          ? [...result.map(({ id }) => ({ type: "Properties" as const, id })), { type: "Properties", id: "LIST" }]
          : [{ type: "Properties", id: "LIST" }],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to fetch current residences.",
        });
      },
    }),

    updateTenantSettings: build.mutation<Tenant, { cognitoId: string } & Partial<Tenant>>({
      query: ({ cognitoId, ...updatedTenant }) => ({
        url: `tenants/${cognitoId}`,
        method: "PUT",
        body: updatedTenant,
      }),
      invalidatesTags: (result) => (result ? [{ type: "Tenants", id: result.id }] : []),
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Settings updated successfully!",
          error: "Failed to update settings.",
        });
      },
    }),

    addFavoriteProperty: build.mutation<Tenant, { cognitoId: string; propertyId: number }>({
      query: ({ cognitoId, propertyId }) => ({
        url: `tenants/${cognitoId}/favorites/${propertyId}`,
        method: "POST",
      }),
      invalidatesTags: (result, error, { propertyId }) => [
        { type: "Tenants", id: result?.id },
        { type: "Properties", id: "LIST" },
        { type: "PropertyDetails", id: propertyId },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Added to favorites!",
          error: "Failed to add to favorites.",
        });
      },
    }),

    removeFavoriteProperty: build.mutation<Tenant, { cognitoId: string; propertyId: number }>({
      query: ({ cognitoId, propertyId }) => ({
        url: `tenants/${cognitoId}/favorites/${propertyId}`,
        method: "DELETE",
      }),
      invalidatesTags: (result, error, { propertyId }) => [
        { type: "Tenants", id: result?.id },
        { type: "Properties", id: "LIST" },
        { type: "PropertyDetails", id: propertyId },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Removed from favorites!",
          error: "Failed to remove from favorites.",
        });
      },
    }),

    // Manager related endpoints
    getManagerProperties: build.query<Property[], string>({
      query: (cognitoId) => `managers/${cognitoId}/properties`,
      providesTags: (result, error, cognitoId) => [
          ...(result ?? []).map(({ id }) => ({ type: 'Properties' as const, id })),
          { type: 'Properties', id: 'LIST' },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to load manager properties.",
        });
      },
    }),

    updateManagerSettings: build.mutation<Manager, { cognitoId: string } & Partial<Manager>>({
      query: ({ cognitoId, ...updatedManager }) => ({
        url: `managers/${cognitoId}`,
        method: "PUT",
        body: updatedManager,
      }),
      invalidatesTags: (result) => (result ? [{ type: "Managers", id: result.id }] : []),
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Settings updated successfully!",
          error: "Failed to update settings.",
        });
      },
    }),

    getPropertiesByManagerId: build.query<Property[], string>({
      query: (managerId) => `managers/${managerId}/properties`,
      providesTags: (result, error, managerId) => 
        result 
          ? [
              ...result.map(({ id }) => ({ type: 'Properties' as const, id })),
              { type: 'Properties', id: 'LIST' }, // For list-wide invalidation
            ]
          : [{ type: 'Properties', id: 'LIST' }],
    }),

    // Room related endpoints
    getRooms: build.query<Room[], number>({
      query: (propertyId) => ({
        url: `properties/${propertyId}/rooms`,
        method: 'GET',
      }),
      transformResponse: (response: any) => {
        if (!response || !Array.isArray(response)) {
          console.log('Invalid rooms response:', response);
          return [];
        }
        return response;
      },
      transformErrorResponse: (response: any) => {
        if (response?.status === 404) {
          console.error('Room data not found for property:', response);
          return { data: [] };
        }
        return response;
      },
      providesTags: (result, error, propertyId) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: 'Rooms' as const, id })),
              { type: 'Rooms', id: 'LIST' },
              // Add a property-specific tag to ensure this query is invalidated when rooms for this property change
              { type: 'Rooms', id: `property-${propertyId}` },
            ]
          : [{ type: 'Rooms', id: 'LIST' }, { type: 'Rooms', id: `property-${propertyId}` }],
      onQueryStarted: async (propertyId, { queryFulfilled }) => {
        try {
          await queryFulfilled;
        } catch (error) {
          // Just log the error without showing a toast
          console.error('Error fetching rooms:', error);
          // Don't show toast for room fetch errors as it's disruptive
          // This prevents unnecessary error notifications
        }
      },
    }),

    getRoom: build.query<Room, { propertyId: number, roomId: number }>({
      query: ({ propertyId, roomId }) => `rooms/${roomId}?propertyId=${propertyId}`,
      
      providesTags: (result, error, { roomId }) => [{ type: "Rooms", id: roomId }],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to load room details.",
        });
      },
    }),

    createRoom: build.mutation<Room, { propertyId: number, body: FormData }>({
      // Instead of using the standard query configuration, we'll implement
      // a custom queryFn to have complete control over the fetch request
      async queryFn({ propertyId, body }, _queryApi, _extraOptions, fetchWithBQ) {
        try {
          // First, create the room without photos
          const roomData = {};
          for (const [key, value] of body.entries()) {
            // Skip photo files for initial room creation
            if (key !== 'photos') {
              roomData[key] = value;
            }
          }
          
          // Get auth token
          let token = null;
          try {
            const session = await fetchAuthSession();
            token = session.tokens?.idToken?.toString();
          } catch (e) {
            console.error('Not authenticated:', e);
            throw new Error('Authentication required');
          }
          
          // Create room first
          const createRoomResponse = await fetch(`${API_BASE_URL}/properties/${propertyId}/create-room`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(roomData)
          });
          
          if (!createRoomResponse.ok) {
            const errorData = await createRoomResponse.json().catch(() => ({ message: 'Unknown error' }));
            throw new Error(errorData.message || 'Failed to create room');
          }
          
          const room = await createRoomResponse.json();
          console.log('Room created successfully:', room);
          
          // Now handle photo uploads if any
          const photos = body.getAll('photos');
          if (photos && photos.length > 0) {
            console.log(`Uploading ${photos.length} photos for room ${room.id}`);
            
            const uploadPromises = photos.map(async (photo: File) => {
              const photoData = new FormData();
              photoData.append('photo', photo);
              
              const uploadResponse = await fetch(`${API_BASE_URL}/rooms/${room.id}/photos`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`
                },
                body: photoData
              });
              
              if (!uploadResponse.ok) {
                console.error(`Failed to upload photo ${photo.name}:`, uploadResponse.statusText);
                return null;
              }
              
              return uploadResponse.json();
            });
            
            try {
              const uploadResults = await Promise.all(uploadPromises);
              console.log('Photo upload results:', uploadResults);
              
              // Get updated room with photo URLs
              const updatedRoomResponse = await fetch(`${API_BASE_URL}/rooms/${room.id}?propertyId=${propertyId}`, {
                headers: {
                  'Authorization': `Bearer ${token}`
                }
              });
              
              if (updatedRoomResponse.ok) {
                const updatedRoom = await updatedRoomResponse.json();
                return { data: updatedRoom };
              }
            } catch (uploadError) {
              console.error('Error uploading room photos:', uploadError);
              // Return the room even if photo upload failed
              return { data: room };
            }
          }
          
          return { data: room };
          
          // Handle response
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({
              message: 'Unknown server error'
            }));
            
            console.log('Room creation error response:', { status: response.status, data: errorData });
            
            // Transform error response (moved from transformErrorResponse)
            let transformedError = errorData;
            
            // Handle different error cases
            if (response.status === 404) {
              transformedError = { message: "Property not found" };
            } else if (response.status === 400) {
              transformedError = { 
                message: errorData?.message || "Invalid room data",
                details: errorData
              };
            } else if (response.status === 401) {
              transformedError = { message: "Unauthorized. Please log in again." };
            } else if (response.status === 403) {
              transformedError = { message: "You don't have permission to create rooms" };
            } else {
              // For other errors, try to get a meaningful message
              const errorMessage = errorData?.message || 
                                 errorData?.error || 
                                 "Failed to create room";
                                 
              transformedError = { 
                message: errorMessage,
                details: errorData
              };
            }
            
            return { error: { status: response.status, data: transformedError } };
          }
          
          const data = await response.json();
          // The server returns the room directly (moved from transformResponse)
          return { data };
        } catch (error) {
          console.error('Room creation error:', error);
          
          // Transform the error to match our error format
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          const transformedError = {
            message: errorMessage,
            details: error instanceof Error ? { stack: error.stack } : error
          };
          
          return { 
            error: { 
              status: 500, 
              data: transformedError 
            } 
          };
        }
      },

      invalidatesTags: (result, error) => {
        if (error) return [];
        return result ? [
          { type: 'Rooms', id: 'LIST' },
          { type: 'Rooms', id: result.id },
          { type: 'PropertyDetails', id: result.propertyId },
          // Also invalidate rooms for this property specifically
          { type: 'Rooms', id: `property-${result.propertyId}` }
        ] : [];
      },
      async onQueryStarted(_, { queryFulfilled }) {
        try {
          await queryFulfilled;
        } catch (error: any) {
          console.error("Error creating room:", {
            error,
            message: error?.data?.message,
            details: error?.data?.details,
            status: error?.status
          });
          
          // Show a more detailed error message - ensure it's a string
          let errorMessage = "Failed to create room";
          
          if (typeof error?.data?.message === 'string') {
            errorMessage = error.data.message;
          } else if (typeof error?.data?.error === 'string') {
            errorMessage = error.data.error;
          } else if (typeof error?.error === 'string') {
            errorMessage = error.error;
          } else if (error instanceof Error) {
            errorMessage = error.message;
          }
          
          toast.error(errorMessage);
        }
      },
    }),

    updateRoom: build.mutation<Room, { propertyId: number, roomId: number; data: FormData }>({
      query: ({ propertyId, roomId, data }) => ({
        url: `rooms/${roomId}`,
        method: "PUT",
        body: data,
      }),
      transformResponse: (response: any) => {
        // The server returns the room directly
        return response;
      },
      transformErrorResponse: (response: any) => {
        if (response.status === 404) {
          return { message: "Room not found" };
        }
        if (response.status === 400) {
          return { message: response.data?.message || "Invalid room data" };
        }
        return { message: response.data?.message || "Failed to update room" };
      },
      invalidatesTags: (result, error, { roomId, propertyId }) => {
        if (error) return [];
        return [
          { type: 'Rooms', id: roomId },
          { type: 'Rooms', id: 'LIST' },
          { type: 'PropertyDetails', id: propertyId || result?.propertyId },
          { type: 'Properties', id: propertyId || result?.propertyId }
        ];
      },
      async onQueryStarted(_, { queryFulfilled }) {
        try {
          await queryFulfilled;
          toast.success("Room updated successfully!");
        } catch (error: any) {
          console.error("Error updating room:", error);
          toast.error(error?.data?.message || "Failed to update room");
        }
      },
    }),

    deleteRoom: build.mutation<{ message: string; id: number }, { propertyId: number, roomId: number }>({
      query: ({ propertyId, roomId }) => ({
        url: `rooms/${roomId}?propertyId=${propertyId}`,
        method: "DELETE",
      }),
      invalidatesTags: (result, error, { roomId }) => [
          { type: "Rooms", id: roomId },
          { type: "Rooms", id: "LIST" },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Room deleted successfully!",
          error: "Failed to delete room.",
        });
      },
    }),

    // Lease related endpoints
    getLeases: build.query<Lease[], void>({
      query: () => "leases",
      providesTags: (result) =>
          result
              ? [...result.map(({ id }) => ({ type: 'Leases' as const, id })), { type: 'Leases', id: 'LIST' }]
              : [{ type: 'Leases', id: 'LIST' }],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to fetch leases.",
        });
      },
    }),

    getPropertyLeases: build.query<Lease[], number>({
      query: (propertyId) => ({
        url: `properties/${propertyId}/leases`,
        method: 'GET',
      }),
      transformErrorResponse: (response: any) => {
        if (response?.status === 404) {
          console.error('Property leases not found:', response);
          return { data: [] }; // Return empty array on 404
        }
        return response;
      },
      providesTags: (result, error, propertyId) => [
          ...(result ?? []).map(({ id }) => ({ type: 'Leases' as const, id })),
          { type: 'Leases', id: 'LIST', propertyId },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        try {
          await queryFulfilled;
        } catch (error) {
          console.error("Failed to fetch property leases:", error);
        }
      },
    }),

    getPayments: build.query<Payment[], number>({
      query: (leaseId) => `leases/${leaseId}/payments`,
      providesTags: (result, error, leaseId) => [
          ...(result ?? []).map(({ id }) => ({ type: 'Payments' as const, id })),
          { type: 'Payments', id: 'LIST', leaseId },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to fetch payment info.",
        });
      },
    }),

    // Application related endpoints
    getApplications: build.query<Application[], { userId?: string; userType?: string }>({
      query: (params) => {
        const queryParams = new URLSearchParams();
        if (params.userId) {
          queryParams.append("userId", params.userId.toString());
        }
        if (params.userType) {
          queryParams.append("userType", params.userType);
        }
        const queryString = queryParams.toString();
        return `applications${queryString ? `?${queryString}` : ''}`;
      },
       providesTags: (result) =>
          result
              ? [...result.map(({ id }) => ({ type: 'Applications' as const, id })), { type: 'Applications', id: 'LIST' }]
              : [{ type: 'Applications', id: 'LIST' }],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to fetch applications.",
        });
      },
    }),

    updateApplicationStatus: build.mutation<Application & { lease?: Lease }, { id: number; status: string }>({
      query: ({ id, status }) => ({
        url: `applications/${id}/status`,
        method: "PUT",
        body: { status },
      }),
      // --- CORRECTED invalidatesTags ---
      invalidatesTags: (result, error, { id }) => {
          // Explicitly define the type of the tags array
          const tags: TagDescription<CacheTagType>[] = [
              { type: 'Applications', id },
              { type: 'Applications', id: 'LIST' },
          ];
          // Conditionally add Lease tags if a lease was affected
          if (result?.lease) {
              tags.push({ type: 'Leases', id: 'LIST' });
              tags.push({ type: 'Leases', id: result.lease.id });
          }
          return tags;
      },
      // --- END CORRECTION ---
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Application status updated successfully!",
          error: "Failed to update application status.",
        });
      },
    }),

    createApplication: build.mutation<Application, Partial<Application>>({
      query: (body) => ({
        url: `applications`,
        method: "POST",
        body: body,
      }),
      invalidatesTags: [{ type: "Applications", id: "LIST" }],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Application submitted successfully!",
          error: "Failed to submit application.",
        });
      },
    }),

    // Admin endpoints
    getAllManagers: build.query<(Manager & { status: 'Pending' | 'Active' | 'Disabled' | 'Banned' })[], { status?: string }>({
      query: (params) => {
        const queryParams = new URLSearchParams();
        if (params.status) {
          queryParams.append("status", params.status);
        }
        const queryString = queryParams.toString();
        return `admin/managers${queryString ? `?${queryString}` : ''}`;
      },
      providesTags: (result) =>
        result
          ? [...result.map(({ id }) => ({ type: "Managers" as const, id })), { type: "Managers", id: "LIST" }]
          : [{ type: "Managers", id: "LIST" }],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          error: "Failed to fetch managers.",
        });
      },
    }),

    updateManagerStatus: build.mutation<Manager, { cognitoId: string; status: string; notes?: string }>({
      query: ({ cognitoId, status, notes }) => ({
        url: `admin/managers/${cognitoId}/status`,
        method: "PUT",
        body: { status, notes },
      }),
      invalidatesTags: (result) => [
        { type: "Managers", id: result?.id },
        { type: "Managers", id: "LIST" },
      ],
      async onQueryStarted(_, { queryFulfilled }) {
        await withToast(queryFulfilled, {
          success: "Manager status updated successfully!",
          error: "Failed to update manager status.",
        });
      },
    }),

  }),
});

// Export hooks for usage in components
export const {
  useGetAuthUserQuery,
  useUpdateTenantSettingsMutation,
  useUpdateManagerSettingsMutation,
  useGetPropertiesQuery,
  useGetPropertyQuery,
  useGetCurrentResidencesQuery,
  useGetManagerPropertiesQuery,
  useCreatePropertyMutation,
  useUpdatePropertyMutation,
  useDeletePropertyMutation,
  useGetTenantQuery,
  useAddFavoritePropertyMutation,
  useRemoveFavoritePropertyMutation,
  useGetLeasesQuery,
  useGetPropertyLeasesQuery,
  useGetPaymentsQuery,
  useGetApplicationsQuery,
  useUpdateApplicationStatusMutation,
  useCreateApplicationMutation,
  // Admin-specific hooks
  useGetAllManagersQuery,
  useUpdateManagerStatusMutation,

  // Room endpoints
  useGetRoomsQuery,
  useGetRoomQuery,
  useCreateRoomMutation,
  useUpdateRoomMutation,
  useDeleteRoomMutation,
  useGetPropertiesByManagerIdQuery,
} = api;
